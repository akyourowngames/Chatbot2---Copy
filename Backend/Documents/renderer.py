"""
Document Renderer - HTML to PDF Engine
=======================================
Renders HTML templates to PDF using:
1. Primary: Playwright (headless Chromium)
2. Fallback: WeasyPrint (pure Python)
3. Last resort: Return HTML/Markdown
"""

import os
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, select_autoescape

# Template directory
TEMPLATE_DIR = Path(__file__).parent / "templates"
OUTPUT_DIR = Path(__file__).parent.parent.parent / "Data" / "Documents"

class DocumentRenderer:
    """
    Renders structured document content to PDF.
    Uses Playwright as primary, WeasyPrint as fallback.
    """
    
    def __init__(self):
        # Ensure output directory exists
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        
        # Setup Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(TEMPLATE_DIR)),
            autoescape=select_autoescape(['html', 'xml'])
        )
        
        # Load CSS design system once
        css_path = TEMPLATE_DIR / "design_system.css"
        self.css_content = css_path.read_text() if css_path.exists() else ""
        
        # Template mapping
        self.templates = {
            "expo_submission": "expo_submission.html",
            "pitch_document": "pitch_document.html",
            "technical_guide": "technical_guide.html",
            "professional_report": "professional_report.html"
        }
        
        # Check available renderers
        self._playwright_available = None
        self._weasyprint_available = None
    
    def _check_playwright(self) -> bool:
        """Check if Playwright is available."""
        if self._playwright_available is None:
            try:
                from playwright.async_api import async_playwright
                self._playwright_available = True
            except ImportError:
                self._playwright_available = False
                print("[Renderer] Playwright not installed. Will try WeasyPrint.")
        return self._playwright_available
    
    def _check_weasyprint(self) -> bool:
        """Check if WeasyPrint is available."""
        if self._weasyprint_available is None:
            try:
                import weasyprint
                self._weasyprint_available = True
            except ImportError:
                self._weasyprint_available = False
                print("[Renderer] WeasyPrint not installed.")
        return self._weasyprint_available
    
    def render_html(self, content: Dict[str, Any]) -> str:
        """
        Render document content to HTML string.
        
        Args:
            content: Validated document schema dict
            
        Returns:
            Complete HTML string
        """
        doc_type = content.get("document_type", "professional_report")
        template_name = self.templates.get(doc_type, "professional_report.html")
        
        # Add date if not present
        if not content.get("date"):
            content["date"] = datetime.now().strftime("%B %d, %Y")
        
        # Inject CSS content
        content["css_content"] = self.css_content
        
        try:
            template = self.jinja_env.get_template(template_name)
            html = template.render(**content)
            return html
        except Exception as e:
            print(f"[Renderer] Template error: {e}")
            # Fallback to base template
            try:
                template = self.jinja_env.get_template("base.html")
                return template.render(**content)
            except:
                return self._emergency_html(content)
    
    def _emergency_html(self, content: Dict[str, Any]) -> str:
        """Generate minimal HTML when templates fail."""
        title = content.get("title", "Document")
        sections_html = ""
        for s in content.get("sections", []):
            sections_html += f"<h2>{s.get('heading', '')}</h2>"
            sections_html += f"<p>{s.get('content', '')}</p>"
        
        return f"""<!DOCTYPE html>
<html><head><title>{title}</title>
<style>body{{font-family:sans-serif;max-width:800px;margin:0 auto;padding:2rem}}</style>
</head><body>
<h1>{title}</h1>
{sections_html}
<footer><p>Generated by Kai AI</p></footer>
</body></html>"""
    
    async def _render_pdf_playwright(self, html: str, output_path: str) -> bool:
        """Render PDF using Playwright (primary method)."""
        try:
            from playwright.async_api import async_playwright
            
            async with async_playwright() as p:
                browser = await p.chromium.launch()
                page = await browser.new_page()
                
                # Set content
                await page.set_content(html, wait_until="networkidle")
                
                # Generate PDF
                await page.pdf(
                    path=output_path,
                    format="A4",
                    margin={"top": "0.75in", "bottom": "0.75in", "left": "0.75in", "right": "0.75in"},
                    print_background=True
                )
                
                await browser.close()
                print(f"[Renderer] ✅ PDF generated with Playwright: {output_path}")
                return True
                
        except Exception as e:
            print(f"[Renderer] ❌ Playwright error: {e}")
            return False
    
    def _render_pdf_weasyprint(self, html: str, output_path: str) -> bool:
        """Render PDF using WeasyPrint (fallback method)."""
        try:
            from weasyprint import HTML
            
            HTML(string=html).write_pdf(output_path)
            print(f"[Renderer] ✅ PDF generated with WeasyPrint: {output_path}")
            return True
            
        except Exception as e:
            print(f"[Renderer] ❌ WeasyPrint error: {e}")
            return False
    
    def render_pdf(
        self, 
        content: Dict[str, Any], 
        filename: str = None,
        user_id: str = None
    ) -> Dict[str, Any]:
        """
        Render document content to PDF with graceful fallbacks.
        
        Args:
            content: Validated document schema dict
            filename: Custom filename (optional)
            user_id: User ID for storage (optional)
            
        Returns:
            Dict with:
                - success: bool
                - filepath: str (local path)
                - url: str (served URL)
                - format: str (pdf, html, or markdown)
                - error: str (if any)
        """
        title = content.get("title", "Document")
        doc_type = content.get("document_type", "report")
        
        # Generate filename
        if not filename:
            safe_title = "".join(c if c.isalnum() or c in " -_" else "" for c in title)[:50]
            safe_title = safe_title.replace(" ", "_")
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{safe_title}_{timestamp}.pdf"
        
        output_path = str(OUTPUT_DIR / filename)
        
        # Step 1: Render HTML
        print(f"[Renderer] Rendering {doc_type}: {title}")
        html = self.render_html(content)
        
        # Step 2: Try Playwright (primary)
        if self._check_playwright():
            try:
                # Run async in sync context
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                success = loop.run_until_complete(self._render_pdf_playwright(html, output_path))
                loop.close()
                
                if success:
                    return self._build_result(True, output_path, filename, "pdf")
            except Exception as e:
                print(f"[Renderer] Playwright async error: {e}")
        
        # Step 3: Try WeasyPrint (fallback)
        if self._check_weasyprint():
            if self._render_pdf_weasyprint(html, output_path):
                return self._build_result(True, output_path, filename, "pdf")
        
        # Step 4: Save as HTML (last resort before markdown)
        html_filename = filename.replace(".pdf", ".html")
        html_path = str(OUTPUT_DIR / html_filename)
        try:
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(html)
            print(f"[Renderer] ⚠️ Saved as HTML: {html_path}")
            return self._build_result(True, html_path, html_filename, "html", 
                                       warning="PDF rendering failed. Saved as HTML instead.")
        except Exception as e:
            print(f"[Renderer] HTML save error: {e}")
        
        # Step 5: Return Markdown (absolute last resort)
        markdown = self._to_markdown(content)
        md_filename = filename.replace(".pdf", ".md")
        md_path = str(OUTPUT_DIR / md_filename)
        try:
            with open(md_path, "w", encoding="utf-8") as f:
                f.write(markdown)
            return self._build_result(True, md_path, md_filename, "markdown",
                                       warning="All rendering failed. Saved as Markdown.")
        except:
            return self._build_result(False, "", "", "none", 
                                       error="All rendering methods failed.")
    
    def _build_result(
        self, 
        success: bool, 
        filepath: str, 
        filename: str, 
        format: str,
        warning: str = None,
        error: str = None
    ) -> Dict[str, Any]:
        """Build standardized result dict."""
        result = {
            "success": success,
            "filepath": filepath,
            "filename": filename,
            "url": f"/data/Documents/{filename}" if filename else "",
            "format": format
        }
        if warning:
            result["warning"] = warning
        if error:
            result["error"] = error
        return result
    
    def _to_markdown(self, content: Dict[str, Any]) -> str:
        """Convert document content to Markdown (emergency fallback)."""
        lines = []
        lines.append(f"# {content.get('title', 'Document')}")
        if content.get("subtitle"):
            lines.append(f"*{content['subtitle']}*\n")
        
        for section in content.get("sections", []):
            if section.get("heading"):
                lines.append(f"\n## {section['heading']}\n")
            if section.get("content"):
                lines.append(section["content"] + "\n")
            if section.get("type") == "bullets" and section.get("items"):
                for item in section["items"]:
                    lines.append(f"- {item}")
                lines.append("")
            if section.get("type") == "table" and section.get("data"):
                for i, row in enumerate(section["data"]):
                    lines.append("| " + " | ".join(str(c) for c in row) + " |")
                    if i == 0:
                        lines.append("|" + "|".join(["---"] * len(row)) + "|")
                lines.append("")
        
        lines.append(f"\n---\n*{content.get('footer_text', 'Generated by Kai AI')}*")
        return "\n".join(lines)

# Global instance
document_renderer = DocumentRenderer()

# Convenience function
def render_document(content: Dict[str, Any], filename: str = None) -> Dict[str, Any]:
    """Convenience function to render a document."""
    return document_renderer.render_pdf(content, filename)
